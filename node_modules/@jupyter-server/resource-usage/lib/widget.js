import React, { useRef, useState, useEffect } from 'react';
import { ReactWidget } from '@jupyterlab/apputils';
import { requestAPI } from './handler';
import useInterval from './useInterval';
import { formatForDisplay } from './format';
const POLL_INTERVAL_SEC = 5;
const KERNEL_USAGE_CLASS = 'jp-KernelUsage-content';
const TIMEOUT_CLASS = 'jp-KernelUsage-timedOut';
let kernelChangeCallback = null;
const BlankReason = (props) => {
    const { reason } = props;
    if (reason.reason === 'not_supported') {
        return (React.createElement("div", { className: "jp-KernelUsage-section-separator" },
            props.trans.__('Please check with your system administrator that you are running IPyKernel version 6.10.0 or above.'),
            reason.kernel_version
                ? props.trans.__('Detected IPyKernel version: %1', reason.kernel_version)
                : props.trans.__('No IPyKernel installation detected.')));
    }
    else if (reason.reason === 'no_kernel_widget') {
        return (React.createElement("div", { className: "jp-KernelUsage-section-separator" }, props.trans.__('Switch to a notebook or console to see kernel usage details.')));
    }
    else if (reason.reason === 'no_kernel') {
        return (React.createElement("div", { className: "jp-KernelUsage-section-separator" }, props.trans.__('No active kernel found.')));
    }
    else {
        return (React.createElement("div", { className: "jp-KernelUsage-section-separator" }, props.trans.__('Reason: %1.', reason.reason)));
    }
};
const KernelUsage = (props) => {
    var _a;
    const { panel } = props;
    const [kernelId, setKernelId] = useState();
    const [path, setPath] = useState();
    const [usage, setUsage] = useState();
    const [blankStateReason, setReason] = useState({
        reason: 'loading',
    });
    useInterval(async () => {
        if (kernelId && panel.isVisible) {
            requestUsage(kernelId).catch(() => {
                console.warn(`Request failed for ${kernelId}. Kernel restarting?`);
            });
        }
    }, POLL_INTERVAL_SEC * 1000);
    const kernelIdRef = useRef(kernelId);
    kernelIdRef.current = kernelId;
    const requestUsage = (kid) => {
        return requestAPI(`get_usage/${kid}`).then((data) => {
            // The kernel reply may arrive late due to lax timeouts, so we need to
            // check if it is for the current kernel
            var _a;
            if (kid !== kernelIdRef.current) {
                // Ignore outdated response, but preserve current reason
                return;
            }
            if ((_a = data.content) === null || _a === void 0 ? void 0 : _a.reason) {
                const reason = data.content;
                setReason(reason);
                return;
            }
            else {
                setReason(undefined);
            }
            const usage = {
                ...data.content,
                timestamp: new Date(),
                kernel_id: kid,
            };
            setUsage(usage);
        });
    };
    useEffect(() => {
        const createKernelChangeCallback = (panel) => {
            return (_sender, args) => {
                var _a, _b;
                const newKernelId = (_a = args.newValue) === null || _a === void 0 ? void 0 : _a.id;
                if (newKernelId) {
                    setKernelId(newKernelId);
                    const path = (_b = panel === null || panel === void 0 ? void 0 : panel.sessionContext.session) === null || _b === void 0 ? void 0 : _b.model.path;
                    setPath(path);
                    requestUsage(newKernelId);
                }
                else {
                    // Kernel was disposed
                    setReason({ reason: 'no_kernel' });
                    setKernelId(newKernelId);
                }
            };
        };
        const notebookChangeCallback = (_, panel) => {
            var _a, _b, _c, _d, _e;
            if (panel === null) {
                setKernelId(undefined);
                setReason({
                    reason: 'no_kernel_widget',
                });
                return;
            }
            if (kernelChangeCallback) {
                kernelChangeCallback.panel.sessionContext.kernelChanged.disconnect(kernelChangeCallback.callback);
            }
            kernelChangeCallback = {
                callback: createKernelChangeCallback(panel),
                panel,
            };
            panel.sessionContext.kernelChanged.connect(kernelChangeCallback.callback);
            if (((_b = (_a = panel.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.id) !== kernelId) {
                const kernelId = (_d = (_c = panel.sessionContext.session) === null || _c === void 0 ? void 0 : _c.kernel) === null || _d === void 0 ? void 0 : _d.id;
                if (kernelId) {
                    setKernelId(kernelId);
                    const path = (_e = panel.sessionContext.session) === null || _e === void 0 ? void 0 : _e.model.path;
                    setPath(path);
                    setUsage(undefined);
                    setReason({ reason: 'loading' });
                    requestUsage(kernelId);
                }
                else {
                    setKernelId(undefined);
                    setReason({ reason: 'no_kernel' });
                }
            }
        };
        props.tracker.currentChanged.connect(notebookChangeCallback);
        if (props.tracker.currentWidget) {
            notebookChangeCallback(props.tracker, props.tracker.currentWidget);
        }
        return () => {
            props.tracker.currentChanged.disconnect(notebookChangeCallback);
            // In the ideal world we would disconnect kernelChangeCallback from
            // last panel here, but this can lead to a race condition. Instead,
            // we make sure there is ever only one callback active by holding
            // it in a global state.
        };
    }, [kernelId]);
    if (blankStateReason &&
        (blankStateReason === null || blankStateReason === void 0 ? void 0 : blankStateReason.reason) !== 'timeout' &&
        (blankStateReason === null || blankStateReason === void 0 ? void 0 : blankStateReason.reason) !== 'loading') {
        return (React.createElement(React.Fragment, null,
            React.createElement("h3", { className: "jp-KernelUsage-section-separator" }, props.trans.__('Kernel usage not available')),
            React.createElement(BlankReason, { trans: props.trans, reason: blankStateReason })));
    }
    if (kernelId) {
        return (React.createElement(React.Fragment, null,
            React.createElement("h3", { className: "jp-KernelUsage-section-separator" }, props.trans.__('Kernel usage')),
            (blankStateReason === null || blankStateReason === void 0 ? void 0 : blankStateReason.reason) === 'timeout' ? (React.createElement("strong", null, props.trans.__('Timed out in: %1 ms', blankStateReason.timeout_ms))) : null,
            React.createElement("div", { className: "jp-KernelUsage-separator" },
                props.trans.__('Notebook:'),
                " ",
                path),
            React.createElement("div", { className: "jp-KernelUsage-separator" },
                props.trans.__('Kernel ID:'),
                " ",
                kernelId),
            React.createElement("div", { className: (blankStateReason === null || blankStateReason === void 0 ? void 0 : blankStateReason.reason) === 'timeout' ? TIMEOUT_CLASS : '' }, usage ? (React.createElement(React.Fragment, null,
                React.createElement("div", { className: "jp-KernelUsage-separator" },
                    props.trans.__('Kernel Host:'),
                    " ",
                    usage.hostname),
                React.createElement("div", { className: "jp-KernelUsage-separator" },
                    props.trans.__('Timestamp:'),
                    ' ', (_a = usage.timestamp) === null || _a === void 0 ? void 0 :
                    _a.toLocaleString()),
                React.createElement("div", { className: "jp-KernelUsage-separator" },
                    props.trans.__('Process ID:'),
                    " ",
                    usage.pid),
                React.createElement("div", { className: "jp-KernelUsage-separator" },
                    props.trans.__('CPU:'),
                    " ",
                    usage.kernel_cpu),
                React.createElement("div", { className: "jp-KernelUsage-separator" },
                    props.trans.__('Memory:'),
                    ' ',
                    formatForDisplay(usage.kernel_memory)),
                React.createElement("hr", { className: "jp-KernelUsage-section-separator" }),
                (usage === null || usage === void 0 ? void 0 : usage.host_usage_flag) ? (React.createElement(React.Fragment, null,
                    React.createElement("h4", { className: "jp-KernelUsage-section-separator" }, props.trans.__('Host CPU')),
                    usage.host_cpu_percent && (React.createElement("div", { className: "jp-KernelUsage-separator" }, props.trans._n('%2%% used on %1 CPU', '%2%% used on %1 CPUs', usage.cpu_count, usage.host_cpu_percent.toFixed(1)))),
                    React.createElement("h4", { className: "jp-KernelUsage-section-separator" }, props.trans.__('Host Virtual Memory')),
                    React.createElement("div", { className: "jp-KernelUsage-separator" },
                        props.trans.__('Active:'),
                        ' ',
                        formatForDisplay(usage.host_virtual_memory.active)),
                    React.createElement("div", { className: "jp-KernelUsage-separator" },
                        props.trans.__('Available:'),
                        ' ',
                        formatForDisplay(usage.host_virtual_memory.available)),
                    React.createElement("div", { className: "jp-KernelUsage-separator" },
                        props.trans.__('Free:'),
                        ' ',
                        formatForDisplay(usage.host_virtual_memory.free)),
                    React.createElement("div", { className: "jp-KernelUsage-separator" },
                        props.trans.__('Inactive:'),
                        ' ',
                        formatForDisplay(usage.host_virtual_memory.inactive)),
                    usage.host_virtual_memory.percent && (React.createElement("div", { className: "jp-KernelUsage-separator" },
                        props.trans.__('Percent used:'),
                        ' ',
                        usage.host_virtual_memory.percent.toFixed(1),
                        "%")),
                    React.createElement("div", { className: "jp-KernelUsage-separator" },
                        props.trans.__('Total:'),
                        ' ',
                        formatForDisplay(usage.host_virtual_memory.total)),
                    React.createElement("div", { className: "jp-KernelUsage-separator" },
                        props.trans.__('Wired:'),
                        ' ',
                        formatForDisplay(usage.host_virtual_memory.wired)))) : null)) : (blankStateReason === null || blankStateReason === void 0 ? void 0 : blankStateReason.reason) === 'loading' ? (React.createElement("div", { className: "jp-KernelUsage-separator" }, props.trans.__('Loading…'))) : (React.createElement("div", { className: "jp-KernelUsage-separator" }, props.trans.__('Usage data is missing'))))));
    }
    return React.createElement("h3", null, props.trans.__('Kernel usage is missing'));
};
export class KernelUsageWidget extends ReactWidget {
    constructor(props) {
        super();
        this._tracker = props.tracker;
        this._panel = props.panel;
        this._trans = props.trans;
        this.addClass(KERNEL_USAGE_CLASS);
    }
    render() {
        return (React.createElement(KernelUsage, { tracker: this._tracker, panel: this._panel, trans: this._trans }));
    }
}
