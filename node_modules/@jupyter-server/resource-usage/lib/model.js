// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { VDomModel } from '@jupyterlab/apputils';
import { URLExt } from '@jupyterlab/coreutils';
import { ServerConnection } from '@jupyterlab/services';
import { Poll } from '@lumino/polling';
import { MEMORY_UNIT_LIMITS, convertToLargestUnit } from './format';
/**
 * Number of values to keep in memory.
 */
const N_BUFFER = 20;
/**
 * A namespace for ResourcUsage statics.
 */
export var ResourceUsage;
(function (ResourceUsage) {
    /**
     * A model for the resource usage items.
     */
    class Model extends VDomModel {
        /**
         * Construct a new resource usage model.
         *
         * @param options The options for creating the model.
         */
        constructor(options) {
            super();
            this._memoryAvailable = false;
            this._cpuAvailable = false;
            this._currentMemory = 0;
            this._currentCpuPercent = 0;
            this._memoryLimit = null;
            this._cpuLimit = null;
            this._units = 'B';
            this._warn = false;
            this._values = [];
            for (let i = 0; i < N_BUFFER; i++) {
                this._values.push({ memoryPercent: 0, cpuPercent: 0 });
            }
            this._poll = new Poll({
                factory: () => Private.factory(),
                frequency: {
                    interval: options.refreshRate,
                    backoff: true,
                },
                name: '@jupyterlab/statusbar:ResourceUsage#metrics',
            });
            this._poll.ticked.connect((poll) => {
                const { payload, phase } = poll.state;
                if (phase === 'resolved') {
                    this._updateMetricsValues(payload);
                    return;
                }
                if (phase === 'rejected') {
                    const oldMemoryAvailable = this._memoryAvailable;
                    const oldCpuAvailable = this._cpuAvailable;
                    this._memoryAvailable = false;
                    this._cpuAvailable = false;
                    this._currentMemory = 0;
                    this._memoryLimit = null;
                    this._cpuLimit = null;
                    this._units = 'B';
                    if (oldMemoryAvailable || oldCpuAvailable) {
                        this.stateChanged.emit();
                    }
                    return;
                }
            });
        }
        /**
         * A promise that resolves after the next request.
         */
        async refresh() {
            await this._poll.refresh();
            await this._poll.tick;
        }
        /**
         * Whether the metrics server extension is available.
         */
        get metricsAvailable() {
            return this._memoryAvailable || this._cpuAvailable;
        }
        /**
         * Whether the memory metric is available.
         */
        get memoryAvailable() {
            return this._memoryAvailable;
        }
        /**
         * Whether the cpu metric is available.
         */
        get cpuAvailable() {
            return this._cpuAvailable;
        }
        /**
         * The current memory usage.
         */
        get currentMemory() {
            return this._currentMemory;
        }
        /**
         * The current memory limit, or null if not specified.
         */
        get memoryLimit() {
            return this._memoryLimit;
        }
        /**
         * The current cpu limit, or null if not specified.
         */
        get cpuLimit() {
            return this._cpuLimit;
        }
        /**
         * The units for memory usages and limits.
         */
        get units() {
            return this._units;
        }
        /**
         * The current cpu percent.
         */
        get currentCpuPercent() {
            return this._currentCpuPercent;
        }
        /**
         * Get a list of the last metric values.
         */
        get values() {
            return this._values;
        }
        /**
         * The warning for memory usage.
         */
        get usageWarning() {
            return this._warn;
        }
        /**
         * Dispose of the memory usage model.
         */
        dispose() {
            super.dispose();
            this._poll.dispose();
        }
        /**
         * Given the results of the metrics request, update model values.
         *
         * @param value The metric request result.
         */
        _updateMetricsValues(value) {
            var _a, _b, _c;
            if (value === null) {
                this._memoryAvailable = false;
                this._cpuAvailable = false;
                this._currentMemory = 0;
                this._memoryLimit = null;
                this._units = 'B';
                this._warn = false;
                return;
            }
            const numBytes = (_a = value.pss) !== null && _a !== void 0 ? _a : value.rss;
            const memoryLimits = value.limits.memory;
            const memoryLimit = (_c = (_b = memoryLimits === null || memoryLimits === void 0 ? void 0 : memoryLimits.pss) !== null && _b !== void 0 ? _b : memoryLimits === null || memoryLimits === void 0 ? void 0 : memoryLimits.rss) !== null && _c !== void 0 ? _c : null;
            const [currentMemory, units] = convertToLargestUnit(numBytes);
            const usageWarning = value.limits.memory
                ? value.limits.memory.warn
                : false;
            this._memoryAvailable = numBytes !== undefined;
            this._currentMemory = currentMemory;
            this._units = units;
            this._memoryLimit = memoryLimit
                ? memoryLimit / MEMORY_UNIT_LIMITS[units]
                : null;
            const memoryPercent = this.memoryLimit
                ? Math.min(this._currentMemory / this.memoryLimit, 1)
                : 0;
            this._warn = usageWarning;
            this._cpuLimit = value.limits.cpu ? value.limits.cpu.cpu : null;
            this._cpuAvailable = value.cpu_percent !== undefined;
            this._currentCpuPercent =
                value.cpu_percent !== undefined ? value.cpu_percent / 100 : 0;
            this._values.push({ memoryPercent, cpuPercent: this._currentCpuPercent });
            this._values.shift();
            this.stateChanged.emit(void 0);
        }
    }
    ResourceUsage.Model = Model;
})(ResourceUsage || (ResourceUsage = {}));
/**
 * A namespace for module private statics.
 */
var Private;
(function (Private) {
    /**
     * Settings for making requests to the server.
     */
    const SERVER_CONNECTION_SETTINGS = ServerConnection.makeSettings();
    /**
     * The url endpoint for making requests to the server.
     */
    const METRIC_URL = URLExt.join(SERVER_CONNECTION_SETTINGS.baseUrl, 'api/metrics/v1');
    /**
     * Make a request to the backend.
     */
    Private.factory = async () => {
        const request = ServerConnection.makeRequest(METRIC_URL, {}, SERVER_CONNECTION_SETTINGS);
        const response = await request;
        if (response.ok) {
            return await response.json();
        }
        return null;
    };
})(Private || (Private = {}));
